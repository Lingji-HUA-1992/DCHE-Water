/**20180927修改**/
/**制冷剂系统改为水系统**/

/*******************************************************错误总结*******************************************************/

/****/

/********************************************************预编译********************************************************/

/**调用库**/
#include <iostream>
#include <cmath>
#include <fstream>

/**宏定义**/
#define pi 3.14159265
#define e 2.718281828

using namespace std;

/*****************************************************定义全局变量*****************************************************/

/**运行总环境**/
static double Patm = 1.01325e5;                                                      /**标准大气压**/
static double g = 9.8;                                                               /**重力加速度**/

/**换热器热力学参数**/
static double roual = 2700.0, roucu = 8900.0;                                        /**翅片密度，铜管密度**/
static double lal = 203.0, lcu = 407.0;                                              /**翅片导热系数，铜管导热系数**/
static double cal = 880.0, ccu = 390.0;                                              /**翅片比热容，铜管比热容**/

/**除湿材料热力学参数**/
//static double Bd = 0.74422, Cd = 0.09965, Dd = 0.5243;                               //硅胶等温吸附曲线by郑旭师姐
static double Wd0;                                                                   /**硅胶初始吸附量**/
static double roud = 1000, cd = 921.0;                                               /**吸附剂密度，比热容**/
static double RHa[26], Wda[26], RHd[12], Wdd[12];

/**空气参数**/
static double ua;                                                                    //**空气流速**/
static double ha;                                                                    /**空气的对流换热系数**///
static double roua = 1.2;                                                            /**空气密度**/
static double mua = 1.845e-5;                                                        /**空气粘度**/
static double ka = 0.0321;                                                           /**空气导热系数**/
static double cpa = 1035.0, cpg = 1864.0;                                            /**干空气比热容，水蒸气比热容**/
static double hfg = 2260000.0;                                                       /**水的潜热（？0度）**/
static double D0 = 8e-7;

/**制冷剂参数(H20)**/
static double mw = 1500, rouw = 1000, vw = mw / rouw;
static double cw = 4180;                                                             /**制冷剂临界压力**/

/**几何参数(微元划分以换热器本身结构为参考，不考虑实际微元划分)**/
static int ntz = 12, ntx = 4, nf = 128;                                              /**换热器管排数（列数为4），翅片数128**/
static double tf = 1.5e-4, Pf = 2.5e-3, td = 2e-4;                                   /**翅片厚度、fin pitch、硅胶涂覆厚度**/
static double dlx = 22.5e-3, dlz = 24e-3;                                            /**微元横截面长、宽**/
static double Ro = 4.76e-3, Ri = 3.925e-3;                                           /**管外径，管内径**/

static double Aa = 2 * pi * (Ro + td) * (Pf - tf - 2 * td) + 2 * (dlx * dlz - pi * pow (Ro + td,2));
static double Ar = 2 * pi * Ri * Pf;                                                 /**制冷剂侧换热面积**/

static double Va = dlx * dlz * Pf;                                                   /**微元体积**/
static double Val = (dlx * dlz - pi * pow (Ro,2)) * tf;                              /**微元铝体积**/
static double Vcu = Pf * pi * (pow (Ro,2) - pow (Ri,2));                             /**微元铜体积**/
static double Vd = Aa * td, Md = Vd * ntx * ntz * nf * roud;                         /**微元干燥剂体积、干燥剂涂敷质量**/
static double epsal = Val / (Vcu + Val + Vd), epscu = Vcu / (Vcu + Val + Vd), epsd = Vd / (Vcu + Val + Vd);
                                                                                     /**铝、铜、干燥剂比体积**/

static double La = Va / Aa;                                                          /**特征长度：空气体积/空气换热面积**/
static double Lad = Vd / Aa;                                                         /**特征长度：除湿剂体积**/
static double LaHX =  (Vcu + Val + Vd) / Aa;                                         /**特征长度：DCHE基材体积/空气换热面积**/
static double LrHX =  (Vcu + Val + Vd) / Ar;                                         /**特征长度：DCHE基材体积/制冷剂侧换热面积**/

/**实际微元划分几何参数**/
static int nn = 5;                                                                  /**除湿剂微元切分**/
static int ny = 4, ny_multiple = 32;                                                 /**翅片数128(=16个微元*8)（列数为4）**/

static int cycle_XYZ = ny * ntx * ntz;                                               /**实际微元划分个数（列数为4）**/
static double dx = dlx, dn = td / nn, dy = ny_multiple * Pf;                         /**实际微元长度**/

/**时间步长及循环参数**/
static double dlt = 1, dlt_mass = 0.02;                                              /**时间步长**/
static int dlt_ratio = 50;
static int cycle_T = 5;                                                              /**计算循环个数**/
static int cycle_Tc = 180, cycle_Th = 180;                                           /**除湿循环次数，解吸循环次数**/
static bool flag_cycle = 0;                                                          /**初始循环标识：0为蒸发器，1为冷凝器**/

/*******************************************************************************************************************************/

double Water(int i, double Tf, double Tr_BFR, double Tr_2BCK, double Tr_BCK, double *result);

double Air_Humidity(double Yain_BFR, double Yaout_BFR, double Yain_NOW, double ky_BFR, double ky_NOW, double Yd_BFR, double Yd_NOW);
double DCHE_Temp(double Wd_avg_temp, double Tf_BFR, double Tf_FRT, double Tf_BCK, double Wd_avg_BFR, double Yd_BFR, double qst_BFR, double Ta_BFR, double Ya_BFR, double ha_BFR, double ky_BFR, double Tr_BFR, double hr_BFR);
double Air_Temperature(double Tain_BFR, double Taout_BFR, double Tain_NOW, double Ya_BFR, double Yain_NOW, double Yaout_NOW, double ky_NOW, double Yd_NOW, double Tf_BFR, double Tf_NOW);
double Desiccant_Mass(bool flag_ch, int re, double Wd_BFR[], double Yd_temp, double Tf_BFR, double Tf_NOW, double Ya_NOW, double ky_NOW, double qst_BFR, double Wd[]);

double ConvertYd (bool flag_ch, int re, double Tf, double Wd);
double UpdateQst(double Tf, double Wd);
double UpdateKy(double Ta);
double UpdateHa();
double UpdateHr(double Tr, double Tf);
double UpdateFr(double Tr);

/*******************************************************************************************************************************/

int main(){

    cout<<"Coating Amount:"<<Md<<endl;
    cout<<La<<'\t'<<Aa<<'\t'<<Aa * nf * ntx * ntz<<'\t'<<Ar<<'\t'<<Ar * nf * ntx * ntz<<endl;

    /**输出文件定义**/
    ofstream outfileTain;
    ofstream outfileTaout;
    ofstream outfileTa, outfileTa0;
    ofstream outfileYain;
    ofstream outfileYaout;
    ofstream outfileYa, outfileYa0;
    ofstream outfileTf;
    ofstream outfileWd_avg;
    ofstream outfileYd;
    ofstream outfileWd;
    ofstream outfileDESICA;

    outfileTain.open("1-Tain.txt");
    outfileTaout.open("1-Taout.txt");
    outfileTa.open("1-Ta.txt");
    outfileTa0.open("1-Ta_Scaled.txt");
    outfileYain.open("2-Yain.txt");
    outfileYaout.open("2-Yaout.txt");
    outfileYa.open("2-Ya.txt");
    outfileYa0.open("2-Ya_Scaled.txt");
    outfileTf.open("3-Tf.txt");
    outfileWd_avg.open("3-Wd_avg.txt");
    outfileYd.open("3-Yd.txt");
    outfileWd.open("3-Wd.txt");
    outfileDESICA.open("3-desiccant.txt");

    ofstream outfileTr;
    outfileTr.open("4-Tr.txt");
    ofstream outfileHS, outfileHA;
    outfileHS.open("5-HS.txt");
    outfileHA.open("5-HA.txt");

    ifstream infile("0-Input.txt");
    double Tain, Yain, Trin;

    ifstream infile1("0-Isotherm.txt");
    int p;
    for(p = 0; p <= 26; p++){
        infile1>>Wda[p]>>RHa[p];
        if(p <= 12)infile1>>Wdd[p]>>RHd[p];
    }

    /**变量定义**/
    int i, j, k, re;
    int i0, j0;

    double Yain_BFR, Yaout_BFR, Ya_BFR;
    double Yain_NOW, Yaout_NOW, Ya_NOW;
    double Tain_BFR, Taout_BFR, Ta_BFR;
    double Tain_NOW, Taout_NOW, Ta_NOW, Ta_temp;
    double ky_BFR, ky_NOW;

    double Taverage;
    double Yaverage;
    double Tf_average, Wd_average, Yd_average;

    double Tf_BFR, Tf_FRT_BFR, Tf_BCK_BFR, Tf_NOW, Tf_temp;
    double Wd_BFR[nn + 1], Wd_BFR_2[nn + 1], Wd_NOW[nn + 1];
    double Wd_avg_BFR, Wd_avg_temp , Wd_avg_NOW;
    double Yd_BFR, Yd_BFR_2, Yd_NOW;
    double qst_BFR, qst_BFR_2, qst_NOW;

    double Tr_NOW, Tr_temp, Tr_BFR, Tr_BCK, Tr_2BCK;
    double hr, fr;

    double *result = &Tr_NOW;
    bool flag_Tr;
    int times_Tr;
    bool flag_Tf, flag_Ta, flag_wd;
    int times_Tf, times_Ta, times_wd;

    /**重要参数微元矩阵**/
    double MTaout_BFR[cycle_XYZ + 1], MTain_BFR[cycle_XYZ + 1], MTain[cycle_XYZ + 1];
    double MYaout_BFR[cycle_XYZ + 1], MYain_BFR[cycle_XYZ + 1], MYain[cycle_XYZ + 1];
    double MTf_BFR[cycle_XYZ + 1], MTf[cycle_XYZ + 1];
    double MWd_BFR[cycle_XYZ + 1][nn + 1];
    double MTr_BFR[cycle_XYZ + 1];

    int r0;
    double Q, Q_total;
    double h_average;
    double Tain_SEG, Taout_SEG, Yain_SEG, Yaout_SEG;
    double dlT_SEG;
    double QS_SEG, QA_SEG;
    double hS_SEG, hA_SEG;

    infile>>Tain>>Yain>>Trin;

    /**赋初值（非制冷剂侧）**/
    if (!flag_cycle) Wd0 = 0.10;
    else Wd0 = 0.30;

    for(i0 = 0; i0 <= cycle_XYZ; i0++) {
        MTain_BFR[i0] = Tain, MTaout_BFR[i0] = Tain;
        MTain[i0] = Tain;
        MYain_BFR[i0] = Yain, MYaout_BFR[i0] = Yain;
        MYain[i0] = Yain;
        MTf[i0] = MTf_BFR[i0] = Tain;
        for(j0 = 0; j0 < nn + 1; j0++)MWd_BFR[i0][j0] = Wd0;
    }

    /**每间隔1单位时间步长进行的计算**/
    for(j = 1; j <= cycle_T * (cycle_Tc + cycle_Th); j++){

        if (j != 1)infile>>Tain>>Yain>>Trin;

        re = j % (cycle_Tc + cycle_Th);

        if((re == 1 && (!flag_cycle))||(re == cycle_Tc + 1 && (flag_cycle))){

            ua = 1;
            ha = UpdateHa();
            //ha = 56;
            cout<<j<<'\t'<<ha<<endl;
        }

        if((re == cycle_Th + 1 && (!flag_cycle))||(re == 1 && (flag_cycle))){
            ua = 1;
            ha = UpdateHa();
            //ha = 56;
            cout<<j<<'\t'<<ha<<endl;
        }

        /**蒸发器冷凝器切换时，切换进出口(非制冷剂侧)**/
        /**if ((re == 1 && j != 1) || ((re == cycle_Tc + 1) && (!flag_cycle))||((re == cycle_Th + 1) && (flag_cycle))){

            //for(i0 = 1; i0 <= cycle_XYZ; i0++)MTf[i0] = MWr_BFR[cycle_XYZ + 1 - i0];
            //for(i0 = 1; i0 <= cycle_XYZ; i0++)MWr_BFR[i0] = mrin / MRour_BFR[i0];
            //for(i0 = 1; i0 <= cycle_XYZ; i0++)MWr_BFR[i0] = MTf[i0];

            //for(i0 = 1; i0 <= cycle_XYZ; i0++)MTf[i0] = MTr_BFR[cycle_XYZ + 1 - i0];
            //for(i0 = 1; i0 <= cycle_XYZ; i0++)MTr_BFR[i0] = MTf[i0];
            //for(i0 = 1; i0 <= cycle_XYZ; i0++)MTf[i0] = MHr_BFR[cycle_XYZ + 1 - i0];
            //for(i0 = 1; i0 <= cycle_XYZ; i0++)MHr_BFR[i0] = MTf[i0];

            for(i0 = 1; i0 <= cycle_XYZ; i0++)MTf[i0] = MYain_BFR[cycle_XYZ + 1 - i0];
            for(i0 = 1; i0 <= cycle_XYZ; i0++)MYain_BFR[i0] = MTf[i0];
            for(i0 = 1; i0 <= cycle_XYZ; i0++)MTf[i0] = MYaout_BFR[cycle_XYZ + 1 - i0];
            for(i0 = 1; i0 <= cycle_XYZ; i0++)MYaout_BFR[i0] = MTf[i0];
            for(i0 = 1; i0 <= cycle_XYZ; i0++)MTf[i0] = MTain_BFR[cycle_XYZ + 1 - i0];
            for(i0 = 1; i0 <= cycle_XYZ; i0++)MTain_BFR[i0] = MTf[i0];
            for(i0 = 1; i0 <= cycle_XYZ; i0++)MTf[i0] = MTaout_BFR[cycle_XYZ + 1 - i0];
            for(i0 = 1; i0 <= cycle_XYZ; i0++)MTaout_BFR[i0] = MTf[i0];

            for(i0 = 1; i0 <= cycle_XYZ; i0++){
                MTf[i0] = MTf_BFR[cycle_XYZ + 1 - i0];
                if (MTf[i0] >= 70) MTf[i0] = 70;
            }
            for(i0 = 1; i0 <= cycle_XYZ; i0++)MTf_BFR[i0] = MTf[i0];
            for(j0 = 0; j0 < nn + 1; j0++){
                for(i0 = 1; i0 <= cycle_XYZ; i0++)MTf[i0] = MWd_BFR[cycle_XYZ + 1 - i0][j0];
                for(i0 = 1; i0 <= cycle_XYZ; i0++)MWd_BFR[i0][j0] = MTf[i0];
            }
        }**/

        /**蒸发冷凝器切换时，初始化制冷剂侧流量**/
    if(((re == 1 || re == cycle_Tc + 1) && (!flag_cycle))||((re == 1 || re == cycle_Th + 1) && (flag_cycle))){

        for(i0 = 0; i0 <= cycle_XYZ; i0++) {

            flag_Tr = 1;
            times_Tr = 1;

            Tr_temp = (i0 == 0)? Trin : MTr_BFR[i0 - 1];

            while (flag_Tr){
                fr = UpdateFr(Tr_temp);
                //fr = 0;
                hr = UpdateHr(Tr_temp,MTf_BFR[i0]);

                switch(i0){
                case 0:
                    Tr_NOW = Trin;
                    break;
                case 1:
                    Tr_NOW  = (2 * rouw * vw * cw * MTr_BFR[i0 - 1] / dy + hr * MTf_BFR[i0] * 2 / Ri - rouw * vw * fr) / (2 * rouw * vw * cw / dy + hr * 2 / Ri);

                    break;
                case 2:
                    Tr_NOW = (3 * rouw * vw * cw * MTr_BFR[i0 - 1] / dy - 4 * rouw * vw * cw * MTr_BFR[i0 - 2] / 3 / dy + hr * MTf_BFR[i0] * 2 / Ri - rouw * vw * fr) / (5 * rouw * vw * cw / 3 / dy + hr * 2 / Ri);
                    break;
                default:
                    Tr_NOW = (2 * rouw * vw * cw * MTr_BFR[i0 - 1] / dy - rouw * vw * cw * MTr_BFR[i0 - 2] / 2 / dy + hr * MTf_BFR[i0] * 2 / Ri - rouw * vw * fr) / (3 * rouw * vw * cw / 2 / dy + hr * 2 / Ri);
                    break;
                }
                flag_Tr = (abs(Tr_NOW - Tr_temp) / Tr_NOW < 1e-4) ? 0 : 1;
                //cout<<i0<<'\t'<<Tr_NOW<<'\t'<<Tr_temp<<'\t'<<flag_Tr<<endl;
                times_Tr++;
                Tr_temp = Tr_NOW;
            }
            MTr_BFR[i0] = Tr_NOW;
            //cout<<MTr_BFR[i0]<<'('<<i0<<'\t'<<hr<<'\t'<<fr<<')'<<'\t';
            outfileTr<<MTr_BFR[i0]<<'('<<i0<<'\t'<<hr<<')'<<'\t';
            if(i0 % ny == 0)outfileTr<<endl;
        }
    }


         /**定义输出变量**/
        Taverage = 0;
        Yaverage = 0;
        Q_total = 0;
        h_average = 0;

        cout<<j<<endl;

        outfileTain<<endl<<j<<endl;
        outfileTaout<<endl<<j<<endl;
        outfileYain<<endl<<j<<endl;
        outfileYaout<<endl<<j<<endl;
        outfileTf<<endl<<j<<endl;;
        outfileWd_avg<<endl<<j<<endl;
        outfileYd<<endl<<j<<endl;
        outfileWd<<endl<<j<<endl;

        outfileTr<<endl<<j<<endl;


        /**边界条件**/
        for(i0 = 1; i0 <= cycle_XYZ; i0++) if ( (i0 % (4 * ny) - 1) / ny == 0) MTain[i0] = Tain, MYain[i0] = Yain;

        Tr_BCK = MTr_BFR[0] = Trin;
        hr = UpdateHr(MTr_BFR[0],MTf_BFR[0]);

        outfileTr<<MTr_BFR[0]<<'('<<'0'<<'\t'<<hr<<')'<<endl;


        /**每个微元内进行的计算**/
        for(i = 1; i <= cycle_XYZ; i++){

            /**输入前一个时间节点或位置节点的值**/
            if(i != 1){
                Tr_2BCK = Tr_BCK, Tr_BCK = Tr_NOW;
            }

            Tr_BFR = MTr_BFR[i];

            Yain_BFR = MYain_BFR[i];
            Yaout_BFR = MYaout_BFR[i];
            Tain_BFR = MTain_BFR[i];
            Taout_BFR = MTaout_BFR[i];

            Tf_BFR = MTf_BFR[i];
            if(i == 1)Tf_FRT_BFR = MTf_BFR[i], Tf_BCK_BFR = MTf_BFR[i + 1];
            //if(i == 1)Tf_FRT_BFR = (4 * MTf_BFR[i] - MTf_BFR[i + 1]) / 3, Tf_BCK_BFR = MTf_BFR[i + 1];
            else {
                //if(i == cycle_XYZ)Tf_FRT_BFR = MTf_BFR[i - 1], Tf_BCK_BFR = (4 * MTf_BFR[i] - MTf_BFR[i - 1]) / 3;
                if(i == cycle_XYZ)Tf_FRT_BFR = MTf_BFR[i - 1], Tf_BCK_BFR = MTf_BFR[i];
                else Tf_FRT_BFR = MTf_BFR[i - 1], Tf_BCK_BFR = MTf_BFR[i + 1];
            }
            for(i0 = 0; i0 < nn + 1; i0++) Wd_BFR[i0] = MWd_BFR[i][i0];

            Yain_NOW = MYain[i];
            Tain_NOW = MTain[i];
            Ya_BFR = Yain_BFR / 2 + Yaout_BFR / 2;
            Ta_BFR = Tain_BFR / 2 + Taout_BFR / 2;
            ky_BFR = UpdateKy(Ta_BFR);

            Wd_avg_BFR = 0;
            for(i0 = 0;i0 < nn + 1;i0++){
                if(i0 == 0 || i0 == nn)Wd_avg_BFR = Wd_avg_BFR + Wd_BFR[i0] / 2 / nn;
                else Wd_avg_BFR = Wd_avg_BFR + Wd_BFR[i0] / nn;
            }
            Wd_avg_temp = Wd_avg_BFR;
            Yd_BFR = ConvertYd(flag_cycle,re,Tf_BFR, Wd_BFR[nn]);
            Yd_NOW = Yd_BFR;
            qst_BFR = UpdateQst(Tf_BFR, Wd_avg_BFR);

            outfileTain<<Tain_NOW<<'('<<i<<')'<<'\t';
            if(i % ny == 0)outfileTain<<endl;
            outfileYain<<Yain_NOW<<'('<<i<<')'<<'\t';
            if(i % ny == 0)outfileYain<<endl;

            /**假设已知Wd_NOW[11]，故Yd_NOW, Wd_avg_temp可知**/
            flag_wd = 1;
            times_wd = 1;
            while(flag_wd){
                /**假设已知Ta_temp，故ky_NOW可知**/
                Ta_temp = Tain_BFR / 2 + Taout_BFR / 2;
                flag_Ta = 1;
                times_Ta = 1;
                while (flag_Ta){
                    ky_NOW = UpdateKy(Ta_temp);
                    Yaout_NOW = Air_Humidity(Yain_BFR,Yaout_BFR,Yain_NOW,ky_BFR,ky_NOW,Yd_BFR,Yd_NOW);
                    Ya_NOW = Yain_NOW / 2 + Yaout_NOW / 2;
                    Tf_temp = Tf_BFR;
                    flag_Tf = 1;
                    times_Tf = 1;
                    while (flag_Tf){
                        hr = Water(i,Tf_temp,Tr_BFR,Tr_2BCK,Tr_BCK,result);
                        Tf_NOW = DCHE_Temp(Wd_avg_temp,Tf_BFR,Tf_FRT_BFR,Tf_BCK_BFR,Wd_avg_BFR,Yd_BFR,qst_BFR,Ta_temp,Ya_BFR,ha,ky_BFR,Tr_NOW,hr);
                        //if(j==61)cout<<i<<'\t'<<Tf_NOW<<'\t'<<Tf_temp<<'\t'<<hr<<'\t'<<Tr<<endl;
                        flag_Tf = (abs(Tf_NOW - Tf_temp) / Tf_NOW < 1e-4) ? 0 : 1;
                        Tf_temp = Tf_NOW;
                        times_Tf++;
                    }
                    Taout_NOW = Air_Temperature(Tain_BFR,Taout_BFR,Tain_NOW,Ya_BFR,Yain_NOW,Yaout_NOW,ky_NOW,Yd_NOW,Tf_BFR,Tf_NOW);
                    Ta_NOW = Tain_NOW / 2 + Taout_NOW / 2;
                    //if(j==83)cout<<i<<'\t'<<"Ta"<<'\t'<<Ta_NOW<<'\t'<<Ta_temp<<endl;
                    flag_Ta = (abs(Ta_NOW - Ta_temp) / Ta_NOW < 1e-4) ? 0 : 1;
                    Ta_temp = Ta_NOW;
                    times_Ta++;
                }
                for(i0 = 0; i0 < nn + 1; i0++)Wd_BFR_2[i0] = Wd_BFR[i0];
                Yd_BFR_2 = Yd_BFR;
                qst_BFR_2 = qst_BFR;

                for(k=0;k<dlt_ratio;k++){
                    Wd_avg_NOW = Desiccant_Mass(flag_cycle,re,Wd_BFR_2,Yd_BFR_2,(Tf_NOW-Tf_BFR)*k/dlt_ratio+Tf_BFR,(Tf_NOW-Tf_BFR)*(k+1)/dlt_ratio+Tf_BFR,(Ya_NOW-Ya_BFR)*(k+1)/dlt_ratio+Ya_BFR,(ky_NOW-ky_BFR)*(k+1)/dlt_ratio+ky_BFR,qst_BFR_2,Wd_NOW);
                    for(i0 = 0; i0 < nn + 1; i0++)Wd_BFR_2[i0] = Wd_NOW[i0];
                    Yd_NOW = ConvertYd(flag_cycle,re,(Tf_NOW-Tf_BFR)*(k+1)/dlt_ratio+Tf_BFR,Wd_NOW[nn]);
                    Yd_BFR_2 = Yd_NOW;
                    qst_BFR_2 = UpdateQst((Tf_NOW-Tf_BFR)*k/dlt_ratio+Tf_BFR,Wd_avg_NOW);
                    //cout<<i<<'\t'<<k<<'\t'<<Wd_avg_NOW<<endl;
                }

                flag_wd = (abs(Wd_avg_NOW - Wd_avg_temp) / Wd_avg_NOW < 1e-4) ? 0 : 1;
                //if(j==83)cout<<i<<'\t'<<"WD"<<'\t'<<times_wd<<'\t'<<Wd_avg_NOW<<'\t'<<Wd_avg_temp<<endl;
                //if(times_wd >= 10)Wd_avg_temp = Wd_avg_NOW / 2 + Wd_avg_temp / 2;
                Wd_avg_temp = Wd_avg_NOW;

                times_wd++;
            }

            MYain_BFR[i] = Yain_NOW;
            MYaout_BFR[i] = Yaout_NOW;
            MTain_BFR[i] = Tain_NOW;
            MTaout_BFR[i] = Taout_NOW;
            MTf[i] = Tf_NOW;

            //cout<<i<<'\t'<<Tf_NOW<<endl;
            MTr_BFR[i] = Tr_NOW;

            for(i0 = 0; i0 < nn + 1; i0++)MWd_BFR[i][i0] = Wd_NOW[i0];
            if ( (i % (4 * ny) - 1) / ny == 0) MTain[i / (4 * ny) * 8 * ny + 2 * ny + 1 - i] = MTaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 1) MTain[i / (4 * ny) * 8 * ny + 4 * ny + 1 - i] = MTaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 2) MTain[i / (4 * ny) * 8 * ny + 6 * ny + 1 - i] = MTaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 0) MYain[i / (4 * ny) * 8 * ny + 2 * ny + 1 - i] = MYaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 1) MYain[i / (4 * ny) * 8 * ny + 4 * ny + 1 - i] = MYaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 2) MYain[i / (4 * ny) * 8 * ny + 6 * ny + 1 - i] = MYaout_BFR[i];

            Q = (Tf_NOW - Tf_BFR) * (roucu * epscu * ccu + roual * epsal * cal + roud * epsd * cd + roud * epsd * cpg * Wd_avg_NOW) * (Vcu + Val + Vd) * ny_multiple / 1000;
            Q_total = Q_total + Q;
            h_average = h_average + hr / ny / ntz / ntx;


            outfileTaout<<Taout_NOW<<'('<<i<<')'<<'\t';
            if(i % ny == 0)outfileTaout<<endl;
            outfileYaout<<Yaout_NOW<<'('<<i<<'\t'<<ky_NOW<<')'<<'\t';
            if(i % ny == 0)outfileYaout<<endl;

            outfileTf<<Tf_NOW<<'('<<i<<'\t'<<Tf_BFR<<')'<<'\t';
            if(i % ny == 0)outfileTf<<endl;
            outfileWd_avg<<Wd_avg_NOW<<'('<<i<<'\t'<<Wd_avg_BFR<<'\t'<<ky_NOW<<')'<<'\t';
            if(i % ny == 0)outfileWd_avg<<endl;

            if(i==1) outfileDESICA<<endl<<j;
            if(i %(ntx * ny)==0){
                Tf_average = 0;
                Wd_average = 0;
                for (i0 = 0; i0<ny*ntx; i0++){
                    Tf_average = MTf[i-i0]/ny/ntx + Tf_average;
                    Wd_average = MWd_BFR[i-i0][nn]/ny/ntx + Wd_average;
                }
                Yd_average = ConvertYd(flag_cycle,re,Tf_average,Wd_average);
                outfileDESICA<<'\t'<<i<<'\t'<<Tf_average<<'\t'<<Yd_average / 1000;
            }
            outfileYd<<Yd_NOW<<'('<<i<<')'<<'\t';
            if(i % ny == 0)outfileYd<<endl;
            if(i % ny == 1){
                for(i0 = 0; i0 < nn + 1; i0++)outfileWd<<MWd_BFR[i][i0]<<'\t';
                outfileWd<<endl;
            }

            outfileTr<<Tr_NOW<<'('<<i<<'\t'<<Tr_BFR<<'\t'<<hr<<')'<<'\t';
            if(i % ny == 0)outfileTr<<endl;
        }

        MTf[0] = 9 * MTf[1] / 8 - MTf[2] / 8;
        for(i0 = 0; i0 <= cycle_XYZ; i0++)MTf_BFR[i0] = MTf[i0];

        for(i0 = 1; i0 <= cycle_XYZ; i0++) {

            if(((i0 - 1) / ny) % 4 == 3){
                Taverage = Taverage + MTaout_BFR[i0] / ny / ntz;
                Yaverage = Yaverage + MYaout_BFR[i0] / ny / ntz;
            }
        }
        for (r0 = 1; r0 <= ntz; r0++){
            Tain_SEG = 0;
            Yain_SEG = 0;
            Taout_SEG = 0;
            Yaout_SEG = 0;
            for (i0 = 1; i0 <= ny ; i0++){
                Tain_SEG = MTain_BFR[ny * ntx * (r0 - 1) + i0] / ny + Tain_SEG;
                Yain_SEG = MYain_BFR[ny * ntx * (r0 - 1) + i0] / ny + Yain_SEG;
                Taout_SEG = MTaout_BFR[ny * ntx * r0 + 1 - i0] / ny + Taout_SEG;
                Yaout_SEG = MYaout_BFR[ny * ntx * r0 + 1 - i0] / ny + Yaout_SEG;
            }
            dlT_SEG = (( Tain_SEG - MTr_BFR[ny * ntx * (r0 - 1)]) - (Taout_SEG - MTr_BFR[ny * ntx * r0]))/log((MTr_BFR[ny * ntx * (r0 - 1)] - Tain_SEG)/(MTr_BFR[ny * ntx * r0] - Taout_SEG));
            QS_SEG = ua * roua * 0.32 * 0.3 * (Tain_SEG * (cpa + cpg * Yain_SEG / 1000) - Taout_SEG * (cpa + cpg * Yaout_SEG / 1000)) / ntz;
            QA_SEG = ua * roua * 0.32 * 0.3 * (Yain_SEG - Yaout_SEG) * 2700 / ntz;
            hS_SEG = QS_SEG / dlT_SEG / Aa / nf / ntx;
            hA_SEG = QA_SEG / dlT_SEG / Aa / nf / ntx;
            outfileHS<<hS_SEG<<'\t';
            outfileHA<<hA_SEG<<'\t';

        }

        outfileHS<<endl;
        outfileHA<<endl;


        outfileTa<<j<<'\t'<<Taverage<<endl;
        if( (j - 1) % 10 == 0)outfileTa0<<j<<'\t'<<Taverage<<endl;
        outfileYa<<j<<'\t'<<Yaverage<<'\t'<<Q_total<<'\t'<<h_average<<'\t'<<MTr_BFR[cycle_XYZ]<<endl;
        if( (j - 1) % 10 == 0)outfileYa0<<j<<'\t'<<Yaverage<<endl;
        //if( (j - 1) % 50 == 0)outfileIrout<<j<<'\t'<<ir<<'\t'<<(1000 * SuperHeatedHT(1000 * SaturatedGPT(45), 80) - ir) * 400 * pi * pow(Ri,2)<<endl;

    }
    outfileTain.close();
    outfileTaout.close();
    outfileTa.close();
    outfileTa0.close();
    outfileYain.close();
    outfileYaout.close();
    outfileYa.close();
    outfileYa0.close();
    outfileTf.close();
    outfileWd_avg.close();
    outfileYd.close();
    outfileWd.close();
    outfileDESICA.close();

    outfileTr.close();
    outfileHS.close();
    outfileHA.close();
    return 0;
}

double Air_Humidity(double Yain_BFR, double Yaout_BFR, double Yain_NOW, double ky_BFR, double ky_NOW, double Yd_BFR, double Yd_NOW){
    double Yaout_NOW;
    double c1 = roua / dlt / 2, c2 = roua * ua / 2 / dx;
    double c3_BFR = ky_BFR / 2 / La, c3_NOW = ky_NOW / 2 / La;
    //Yaout_NOW = ( - c1 * (Yain_NOW - Yain_BFR - Yaout_BFR) - c2 * (Yaout_BFR - Yain_BFR - Yain_NOW) + c3_BFR * (Yd_BFR - Yain_BFR / 2 - Yaout_BFR / 2) + c3_NOW * (Yd_NOW - Yain_NOW / 2)) / (c1 + c2 + c3_NOW / 2);
    //Yaout_NOW = ( - c1 * (Yain_NOW - Yain_BFR - Yaout_BFR) - 2 * c2 * (Yaout_BFR - Yain_BFR) + 2 * c3_BFR * (Yd_BFR - Yain_BFR / 2 - Yaout_BFR / 2)) / c1;
    Yaout_NOW = ( - c1 * (Yain_NOW - Yain_BFR - Yaout_BFR) + 2 * c2 *  Yain_NOW + 2 * c3_NOW * (Yd_NOW - Yain_NOW / 2)) / (c1 + 2 * c2 + c3_NOW);
    return Yaout_NOW;
}

double Air_Temperature(double Tain_BFR, double Taout_BFR, double Tain_NOW, double Ya_BFR, double Yain_NOW, double Yaout_NOW, double ky_NOW, double Yd_NOW, double Tf_BFR, double Tf_NOW){
    double Taout_NOW;
    double Ya_NOW = Yain_NOW / 2 + Yaout_NOW / 2;
    double c1_BFR = roua * (cpa + Ya_BFR * cpg / 1000) / dlt / 2, c1_NOW = roua * (cpa + Ya_NOW * cpg / 1000) / dlt / 2;
    double c2_IN = roua * ua * (cpa + Yain_NOW * cpg / 1000) / dx / 2, c2_OUT = roua * ua * (cpa + Yaout_NOW * cpg / 1000) / dx / 2;
    double c3 = ha / 2 / La;
    double c4 = ky_NOW * cpg * (Yd_NOW - Ya_NOW) / 1000 / 2 / La;
    double Ts;
    if(Yd_NOW <= Ya_NOW) Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW + 2 * c2_IN * Tain_NOW + 2 * c3 * (Tf_NOW - Tain_NOW / 2) + c4 * Tain_NOW) / (c1_NOW + 2 * c2_OUT + c3 - c4);
    else Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW + 2 * c2_IN * Tain_NOW + 2 * c3 * (Tf_NOW - Tain_NOW / 2) + 2 * c4 * Tf_NOW) / (c1_NOW + 2 * c2_OUT + c3);
    //Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW - c2_BFR * (Taout_BFR - Tain_BFR) + c2_NOW * Tain_NOW + c3 * (Tf_BFR - Tain_BFR / 2 - Taout_BFR / 2 + Tf_NOW - Tain_NOW / 2)) / (c1_NOW + c2_NOW + c3 / 2);
    //Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW - 2 * c2_BFR * (Taout_BFR - Tain_BFR) + 2 * c3 * (Tf_BFR - Tain_BFR / 2 - Taout_BFR / 2)) / c1_NOW;
    //Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW + 2 * c2_IN * Tain_NOW + 2 * c3 * (Tf_NOW - Tain_NOW / 2)) / (c1_NOW + 2 * c2_OUT + c3);
    return Taout_NOW;
}

double DCHE_Temp(double Wd_avg_temp, double Tf_BFR, double Tf_FRT, double Tf_BCK, double Wd_avg_BFR, double Yd_BFR, double qst_BFR, double Ta_NOW, double Ya_BFR, double ha, double ky_BFR, double Tr_NOW, double hr){
    double c0, c1, c2_BFR, c2_NOW, c3;
    double qh_BFR;
    double Tf;
    c0 = dlt / dy;
    c1 = roucu * epscu * ccu + roual * epsal * cal + roud * epsd * cd;
    c2_BFR = roud * epsd * cpg * Wd_avg_BFR;
    c2_NOW = roud * epsd * cpg * Wd_avg_temp;
    c3 = epscu * lcu;
    if(Yd_BFR <= Ya_BFR) qh_BFR =  dlt * ( ky_BFR * (Ya_BFR - Yd_BFR) * (qst_BFR + cpg * Ta_NOW) / LaHX / 1000  + ha * Ta_NOW / LaHX + hr * Tr_NOW / LrHX);
    else qh_BFR =  dlt * ( ky_BFR * (Ya_BFR - Yd_BFR) * (qst_BFR + cpg * Tf_BFR) / LaHX / 1000 + ha * Ta_NOW / LaHX + hr * Tr_NOW / LrHX);
    Tf = ((c1 + c2_BFR - 2 * c0 / dy * c3 ) * Tf_BFR + c0 / dy * c3 * (Tf_FRT + Tf_BCK) + qh_BFR) / (c1 + c2_NOW + dlt * ha / LaHX + dlt * hr / LrHX);
    return Tf;
}

double Desiccant_Mass(bool flag_ch, int re, double Wd_BFR[], double Yd_temp, double Tf_BFR, double Tf_NOW, double Ya_NOW, double ky_NOW, double qst_BFR, double Wd_NOW[]){

    int i0, i1, i2, i3, i4;
    int j, k;
    double c0, c1_BFR, c1_NOW;
    double **A = new double*[nn + 1];
    for(i1 = 0;i1 < nn + 1;i1++)A[i1] = new double[nn + 1]();
    double *B = new double[nn + 1]();

    int times_yd = 1;
    bool flag_yd = 1;
    double Yd;
    double qst = qst_BFR;
    double Ds_BFR, Ds_NOW;
    double Wd_avg;


    Ds_BFR =  D0 * exp(-0.974e-6 * qst_BFR / (Tf_BFR + 273.15)) / 20;
    c0 = dn / dlt_mass;
    c1_BFR = Ds_BFR / dn / 2;

    while (flag_yd){
        Ds_NOW =  D0 * exp(-0.974e-6 * qst / (Tf_NOW + 273.15)) / 20;
        c1_NOW = Ds_NOW / dn / 2;

        A[0][0] = 3 * c1_NOW;
        A[0][1] = - 4 * c1_NOW;
        A[0][2] = c1_NOW;
        B[0] = 0;

        for(i2 = 1;i2 < nn;i2++){
            A[i2][i2 - 1] = - c1_NOW;
            A[i2][i2 + 1] = - c1_NOW;
            A[i2][i2] = c0 + 2 * c1_NOW;
            B[i2] = c1_BFR * Wd_BFR[i2 - 1] + c1_BFR * Wd_BFR[i2 + 1] + (c0 - 2 * c1_BFR) * Wd_BFR[i2];
        }
        A[nn][nn - 2] =  c1_NOW;
        A[nn][nn - 1] = - 4 * c1_NOW;
        A[nn][nn] = 3 * c1_NOW;
        B[nn] = ky_NOW * (Ya_NOW - Yd_temp) / roud / 1000;

        for(i3 = 1;i3 < nn;i3++){
            A[i3][i3] = A[i3][i3] - A[i3 - 1][i3] * A[i3][i3 - 1] / A[i3 - 1][i3 - 1];
            A[i3][i3 + 1] = A[i3][i3 + 1] - A[i3 - 1][i3 + 1] * A[i3][i3 - 1] / A[i3 - 1][i3 - 1];
            B[i3]= B[i3] - B[i3 - 1] * A[i3][i3 - 1] / A[i3 - 1][i3 - 1];
            A[i3][i3 - 1] = 0;
        }

        A[nn][nn - 1] = A[nn][nn - 1] - A[nn - 2][nn - 1] * A[nn][nn - 2] / A[nn - 2][nn - 2];
        B[nn]= B[nn] - B[nn - 2] * A[nn][nn - 2] / A[nn - 2][nn - 2];
        A[nn][nn - 2] = 0;
        A[nn][nn] = A[nn][nn] - A[nn - 1][nn] * A[nn][nn - 1] / A[nn - 1][nn - 1];
        B[nn]= B[nn] - B[nn - 1] * A[nn][nn - 1] / A[nn - 1][nn - 1];
        A[nn][nn - 1] = 0;

        Wd_NOW[nn] = B[nn] / A[nn][nn];
        //if(Wd_NOW[nn] >= Bd)Wd_NOW[nn] = Bd;
        for(i4 = nn - 1;i4 >= 1;i4--){
            Wd_NOW[i4] = (B[i4] - A[i4][i4 + 1] * Wd_NOW[i4 + 1]) / A[i4][i4];
        }
        Wd_NOW[0] = (B[0] - A[0][1] * Wd_NOW[1] -  A[0][2] * Wd_NOW[2]) / A[0][0];
        Yd = ConvertYd(flag_ch, re, Tf_NOW, Wd_NOW[nn]);
        flag_yd = (abs(Yd - Yd_temp)<1e-5) ? 0 : 1;
        Yd_temp = Yd;

        Wd_avg = 0;
        for(i0 = 0;i0 < nn + 1;i0++){
            if(i0 == 0 || i0 == nn)Wd_avg = Wd_avg + Wd_NOW[i0] / 2 / nn;
            else Wd_avg = Wd_avg + Wd_NOW[i0] / nn;
        }
        qst = UpdateQst(Tf_NOW, Wd_avg);
        times_yd++;
    }

    delete [] B;
    for(i1 = 0;i1 < nn + 1;i1++) delete [] A[i1];
    delete [] A;
    return Wd_avg;
}

double Water(int i, double Tf, double Tr_BFR, double Tr_2BCK, double Tr_BCK, double *result){

    double Tr_temp = Tr_BFR, Tr_NOW;
    double fr, hr;
    bool flag_Tr = 1;
    int times_Tr = 1;

    while (flag_Tr){
        fr = UpdateFr(Tr_temp);
        //fr = 0;
        hr = UpdateHr(Tr_temp,Tf);
        switch(i){
        case (1):
            Tr_NOW = (rouw * cw * Tr_BFR / dlt + 2 * rouw * vw * cw * Tr_BCK / dy + hr * Tf * 2 / Ri - rouw * vw * fr) / (rouw * cw / dlt + 2 * rouw * vw * cw / dy + hr * 2 / Ri);
            //cout<<Tr_BCK<<endl;
            break;
        case (2):
            Tr_NOW = (rouw * cw * Tr_BFR / dlt + 3 * rouw * vw * cw * Tr_BCK / dy - 4 * rouw * vw * cw * Tr_2BCK / 3 / dy + hr * Tf * 2 / Ri - rouw * vw * fr) / (rouw * cw / dlt + 5 * rouw * vw * cw / 3 / dy + hr * 2 / Ri);
            break;
        default:
            Tr_NOW = (rouw * cw * Tr_BFR / dlt + 2 * rouw * vw * cw * Tr_BCK / dy - rouw * vw * cw * Tr_2BCK / 2 / dy + hr * Tf * 2 / Ri - rouw * vw * fr) / (rouw * cw / dlt + 3 * rouw * vw * cw / 2 / dy + hr * 2 / Ri);
            break;
        }
        flag_Tr = (abs(Tr_NOW - Tr_temp) / Tr_NOW < 1e-4) ? 0 : 1;
        times_Tr++;
        Tr_temp = Tr_NOW;
    }
    *result = Tr_NOW;
    return hr;
}

double ConvertYd (bool flag_ch, int re, double Tf, double Wd){

    double Yd_SAT, Yd, Pvs, RH;

    //Pvs = exp(-5800.2206 / (Tf + 273.15) + 1.3914993 - 0.048640239 * (Tf + 273.15) + 0.000041764768 * pow(Tf + 273.15,2) - 0.000000014452093 * pow(Tf + 273.15,3) + 6.5459673 * log(Tf + 273.15));
    //Yd_SAT = 622  / (Patm / Pvs - 1);
    //Yd = Wd / 0.24 * Yd_SAT;

    int p;
    //if((( re <= cycle_Tc && re != 0) && (!flag_cycle))||((re > cycle_Th || re == 0) && (flag_cycle))){


        for(p = 0; p < 26; p++){
            if(Wda[p] <= Wd && Wd <= Wda[p + 1])break;
            //cout<<Wda[p]<<'\t'<<Wd<<endl;
         }
        if(p == 26){RH = 1;}
        else RH = (Wd - Wda[p]) / (Wda[p + 1] - Wda[p]) * (RHa[p + 1] - RHa[p]) + RHa[p];
    //}
    //else{
         //for(p = 0; p < 12; p++){
            //if(Wdd[p] <= Wd && Wd <= Wdd[p + 1])break;
            //cout<<Wda[p]<<'\t'<<Wd<<endl;
         //}
        //if(p == 12){RH = 1;}
        //else RH = (Wd - Wdd[p]) / (Wdd[p + 1] - Wdd[p]) * (RHd[p + 1] - RHd[p]) + RHd[p];
    //}
    Pvs = exp(-5800.2206 / (Tf + 273.15) + 1.3914993 - 0.048640239 * (Tf + 273.15) + 0.000041764768 * pow(Tf + 273.15,2) - 0.000000014452093 * pow(Tf + 273.15,3) + 6.5459673 * log(Tf + 273.15));

    Yd = 622 * RH / (Patm / Pvs - RH);
    //cout<<p<<'\t'<<Yd<<"here!"<<endl;
    return Yd;


    //if(Wd >= 0.73431) RHd = 1;
    //else {
        //if(Wd >= 0.683 && Wd < 0.73431)RHd = 1 / exp(((Wd -0.68427) / -0.00139 + 36)/ (Tf + 273.15) / (8.314 / 18));
        //else RHd = 1 / exp((pow(- log(Wd / Bd) / Cd, 1/Dd) + 36)/ (Tf + 273.15) / (8.314 / 18));
    //}

    //Pvs = exp(-5800.2206 / (Tf + 273.15) + 1.3914993 - 0.048640239 * (Tf + 273.15) + 0.000041764768 * pow(Tf + 273.15,2) - 0.000000014452093 * pow(Tf + 273.15,3) + 6.5459673 * log(Tf + 273.15));
    //Yd = 622 * RHd / (Patm / Pvs - RHd);
    //return Yd;
}

double UpdateQst(double Tf, double Wd){
    double qst;
    qst = 2700000;
    //qst = hfg * (1.0 + 2.0843 * pow(e,-10.28 * Wd));
    return qst;
}

double UpdateKy(double Ta){

    double ky, Da;
    double NUa, PRa, SCa, SHa;

    Da = 2.302e-5 * pow( (Ta + 273.15) / 256,1.81) * 0.98e5 / Patm;

    NUa = ha * Va / Aa / ka;
    PRa = mua * cpa / ka;
    SCa = mua / roua / Da;
    SHa = NUa * pow(SCa, 1.0 / 3) / pow (PRa , 1.0 / 3);
    ky = roua * SHa * Da * Aa / Va;
    //ky = 0.036;
    return ky;
}

double UpdateHa(){

    double d1, d2;
    double Ao, Afr;
    double af, tht, Dh, dc;
    double Umax, REa, PRa;
    double c3, c4, c5, c6, j;
    double ha;

    d1 = dlz - 2 * Ro;
    d2 = 2 * (pow(pow(dlz / 2, 2) + pow(dlx, 2), 0.5) - 2 * Ro);
    if(d1 < d2) Ao = nf * Pf * (1 - (tf + 2 * td) / Pf) * ((ntz - 1) * d1 + d1);
    else Ao = nf * Pf * (1 - (tf + 2 * td) / Pf) * ((ntz - 1) * d2 + d1);
    Afr = nf * Pf * dlz * ntz;

    af = Aa / Va;
    tht = Ao / Afr;
    Dh = 4 * tht / af;
    dc = 2 * Ro + 2 * td + 2 * tf;

    Umax = ua * Afr / Ao;
    REa = roua * Umax * dc / mua;
    PRa = mua * cpa / ka;                                                              /**普朗克常数：定义式**/

    c3 = - 0.361 - 0.042 * ntx / log(REa) + 0.158 * log(ntx * pow(Pf / dc, 0.41));
    c4 = - 1.224 - 0.076 * pow(dlx / Dh, 1.42) / log(REa);
    c5 = - 0.083 + 0.058 * ntx / log(REa);
    c6 = - 5.735 + 1.21 * log(REa / ntx);
    j = 0.086 * pow(REa, c3) * pow(ntx, c4) * pow(Pf / dc, c5) * pow(Pf / Dh, c6) * pow(Pf / dlz, -0.93);

    ha = j / pow(PRa, 2.0 / 3) * roua * Umax * cpa;

    return ha;
}


double UpdateHr(double Tr, double Tf){

     /**Variable Identification**/
    double uw = -4.40885327e-09 * pow(Tr, 3) + 9.29182730e-07 * pow(Tr, 2) - 5.62086002e-05 * Tr + 1.79738445e-03;
    double kw = -1.53183018e-05 * pow(Tr, 2) + 2.73866448e-03 * Tr + 5.49489965e-01;
    double PR,RE,NUr;                                                                /**制冷剂的普朗克常数,制冷剂的雷诺数**/
    double Hr;
                                                                           /**制冷剂的努赛尔数；制冷剂的对流换热系数**/
    PR = uw * cw / kw;                                                              /**普朗克常数：定义式**/
    RE = fabs(mw) * (2 * Ri) / uw;                                                   /**雷诺数：定义式**/
    if(Tf >= Tr)NUr = 0.023 * pow(RE,0.8) * pow(PR,0.4);                             /**努塞尔数：经验关联式**/
    else NUr = 0.023 * pow(RE,0.8) * pow(PR,0.3);
    Hr = NUr * kw / (2 * Ri);                                                        /**对流换热系数：定义式**/
    return Hr;
}

double UpdateFr(double Tr){

    double mr;
    double fr, Fr, REr;
    double uw = -4.40885327e-09 * pow(Tr, 3) + 9.29182730e-07 * pow(Tr, 2) - 5.62086002e-05 * Tr + 1.79738445e-03;
    REr = 2 * Ri * fabs(mw) / uw;
    Fr = 0.079 / pow(REr, 0.25);
    fr = Fr * pow(mw, 2) / rouw / Ri;
    return fr;
}
    Ta_temp = Tain_BFR / 2 + Taout_BFR / 2;
                flag_Ta = 1;
                times_Ta = 1;
                while (flag_Ta){
                    ky_NOW = UpdateKy(Ta_temp);
                    Yaout_NOW = Air_Humidity(Yain_BFR,Yaout_BFR,Yain_NOW,ky_BFR,ky_NOW,Yd_BFR,Yd_NOW);
                    Ya_NOW = Yain_NOW / 2 + Yaout_NOW / 2;
                    //cout<<Ya_NOW<<endl;
                    Tf_temp = Tf_BFR;
                    flag_Tf = 1;
                    times_Tf = 1;
                    while (flag_Tf){
                        hr = Refrigerant(i,Tf_temp,p1,c1,c2,c3,pr_BCK,pr_BFR,rour_BCK * wr_BCK,qr_BCK,ThPtpr,Result);
                        Tr = Result[3];
                        Tf_NOW = DCHE_Temp(Tf_BFR,Tf_FRT_BFR,Tf_BCK_BFR,Wd_avg_temp,Wd_avg_BFR,Yd_NOW,qst_NOW,Ta_temp,Ya_NOW,ky_NOW,Tr,hr);
                        //cout<<i<<'\t'<<times_Tf<<'\t'<<hr<<'\t'<<Tr<<'\t'<<Tf_NOW<<endl;
                        //cout<<Result[0]<<'\t'<<Result[2]<<endl;
                        //cout<<i<<'\t'<<Tf_NOW<<'\t'<<Tf_temp<<'\t'<<hr<<'\t'<<Tr<<'\t'<<(Tf_NOW - Tf_temp) / Tf_NOW<<endl;
                        flag_Tf = (fabs((Tf_NOW - Tf_temp) / Tf_NOW) < 1e-4) ? 0 : 1;
                        //if(i==33)cout<<i<<'\t'<<Tf_NOW<<'\t'<<fabs(Tf_NOW - Tf_temp) / Tf_NOW<<endl;
                        Tf_temp = Tf_NOW;
                        times_Tf++;
                    }
                    Taout_NOW = Air_Temperature(Tain_BFR,Taout_BFR,Tain_NOW,Ya_BFR,Yain_NOW,Yaout_NOW,ky_NOW,Yd_NOW,Tf_BFR,Tf_NOW);
                    Ta_NOW = Tain_NOW / 2 + Taout_NOW / 2;
                    //cout<<times_Ta<<'\t'<<Ta_NOW<<endl;
                    //cout<<i<<'\t'<<"Ta"<<'\t'<<Ta_NOW<<'\t'<<fabs(Ta_NOW - Ta_temp) / Ta_NOW<<endl;
                    flag_Ta = ((fabs(Ta_NOW - Ta_temp) / Ta_NOW) < 1e-4) ? 0 : 1;
                    Ta_temp = Ta_NOW;
                    times_Ta++;
                }
                for(i0 = 0; i0 < nn + 1; i0++)Wd_BFR_2[i0] = Wd_BFR[i0];
                Yd_BFR_2 = Yd_BFR;
                qst_BFR_2 = qst_BFR;

                for(k=0;k<dlt_ratio;k++){
                    Wd_avg_NOW = Desiccant_Mass(flag_cycle,re,Wd_BFR_2,Yd_BFR_2,(Tf_NOW-Tf_BFR)*k/dlt_ratio+Tf_BFR,(Tf_NOW-Tf_BFR)*(k+1)/dlt_ratio+Tf_BFR,(Ya_NOW-Ya_BFR)*(k+1)/dlt_ratio+Ya_BFR,(ky_NOW-ky_BFR)*(k+1)/dlt_ratio+ky_BFR,qst_BFR_2,Wd_NOW);
                    for(i0 = 0; i0 < nn + 1; i0++)Wd_BFR_2[i0] = Wd_NOW[i0];
                    Yd_BFR_2 = ConvertYd(flag_cycle,re,(Tf_NOW-Tf_BFR)*(k+1)/dlt_ratio+Tf_BFR,Wd_NOW[nn]);
                    qst_BFR_2 = UpdateQst((Tf_NOW-Tf_BFR)*(k+1)/dlt_ratio+Tf_BFR,Wd_avg_NOW);
                    //cout<<i<<'\t'<<k<<'\t'<<Wd_avg_NOW<<endl;
                }
                Yd_NOW = Yd_BFR_2;
                qst_NOW = qst_BFR_2;

                flag_wd = (fabs(Wd_avg_NOW - Wd_avg_temp) / Wd_avg_NOW < 5e-5) ? 0 : 1;
                //cout<<i<<'\t'<<"WD"<<'\t'<<times_wd<<'\t'<<Wd_avg_NOW<<'\t'<<Wd_avg_temp<<endl;
                //if(times_wd >= 10)Wd_avg_temp = Wd_avg_NOW / 2 + Wd_avg_temp / 2;
                Wd_avg_temp = Wd_avg_NOW;

                times_wd++;
            }

            MYain_BFR[i] = Yain_NOW;
            MYaout_BFR[i] = Yaout_NOW;
            MTain_BFR[i] = Tain_NOW;
            MTaout_BFR[i] = Taout_NOW;
            MTf[i] = Tf_NOW;

            //cout<<i<<'\t'<<Tf_NOW<<endl;
            pr = Result[0];
            ir = Result[1];
            xr = Result[2];
            Tr = Result[3];
            epir = Result[4];
            rour = Result[5] ;
            wr = Result[6];
            qr = Result[7];
            momr = Result[8];
            frict = Result[9];

            MPr_BFR[i] = pr;
            MIr_BFR[i] = ir;
            MRour_BFR[i] = rour;
            MWr_BFR[i] = wr;
            MTr_BFR[i] = Tr;
            MHr_BFR[i] = hr;

            for(i0 = 0; i0 < nn + 1; i0++)MWd_BFR[i][i0] = Wd_NOW[i0];
            if ( (i % (4 * ny) - 1) / ny == 0) MTain[i / (4 * ny) * 8 * ny + 2 * ny + 1 - i] = MTaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 1) MTain[i / (4 * ny) * 8 * ny + 4 * ny + 1 - i] = MTaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 2) MTain[i / (4 * ny) * 8 * ny + 6 * ny + 1 - i] = MTaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 0) MYain[i / (4 * ny) * 8 * ny + 2 * ny + 1 - i] = MYaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 1) MYain[i / (4 * ny) * 8 * ny + 4 * ny + 1 - i] = MYaout_BFR[i];
            if ( (i % (4 * ny) - 1) / ny == 2) MYain[i / (4 * ny) * 8 * ny + 6 * ny + 1 - i] = MYaout_BFR[i];

            Q = (Tf_NOW - Tf_BFR) * (roucu * epscu * ccu + roual * epsal * cal + roud * epsd * cd + roud * epsd * cpg * Wd_avg_NOW) * (Vcu + Val + Vd) * ny_multiple / 1000;
            Q_total = Q_total + Q;
            h_average = h_average + hr / ny / ntz / ntx;

            outfileTaout<<Taout_NOW<<'('<<i<<')'<<'\t';
            if(i % ny == 0)outfileTaout<<endl;
            outfileYaout<<Yaout_NOW<<'('<<i<<'\t'<<ky_NOW<<')'<<'\t';
            if(i % ny == 0)outfileYaout<<endl;

            outfileTf<<Tf_NOW<<'('<<i<<'\t'<<Tf_BFR<<')'<<'\t';
            if(i % ny == 0)outfileTf<<endl;
            outfileWd_avg<<Wd_avg_NOW<<'('<<i<<'\t'<<Wd_avg_BFR<<'\t'<<ky_NOW<<')'<<'\t';
            if(i % ny == 0)outfileWd_avg<<endl;
            outfileYd<<Yd_NOW<<'('<<i<<')'<<'\t';
            if(i % ny == 0)outfileYd<<endl;
            if(i % ny == 1){
                for(i0 = 0; i0 < nn + 1; i0++)outfileWd<<MWd_BFR[i][i0]<<'\t';
                outfileWd<<endl;
            }

            if(i==1) outfileOTH<<endl<<j;
            if ((re <= cycle_Tc && re != 0) && (!flag_cycle)){
                if(i == ny * (ntx * 4 + 1)||i == ny * (ntx * 4 + 2)||i == ny * (ntx * 4 + 3)||i == ny * (ntx * 4 + 4)){
                    Tf_average = 0;
                    Wd_average = 0;
                    for (i0 = 0; i0<ny; i0++){
                        Tf_average = MTf[i-i0]/ny + Tf_average;
                        Wd_average = MWd_BFR[i-i0][nn]/ny + Wd_average;
                    }
                    Yd_average = ConvertYd(flag_cycle,re,Tf_average,Wd_average);
                    outfileOTH<<'\t'<<i<<'\t'<<Tf_average<<'\t'<<Yd_average / 1000;
                }
            }
            else{
                if(i == ny * (ntx * 6 + 1)||i == ny * (ntx * 6 + 2)||i == ny * (ntx * 6 + 3)||i == ny * (ntx * 6 + 4)){
                    Tf_average = 0;
                    Wd_average = 0;
                    for (i0 = 0; i0<ny; i0++){
                        Tf_average = MTf[i-i0]/ny + Tf_average;
                        Wd_average = MWd_BFR[i-i0][nn]/ny + Wd_average;
                    }
                    Yd_average = ConvertYd(flag_cycle,re,Tf_average,Wd_average);
                    outfileOTH<<'\t'<<i<<'\t'<<Tf_average<<'\t'<<Yd_average / 1000;
                }
            }
            //else if((cycle_XYZ - i)%(ny*ntx*2)==0)outfileOTH<<'\t'<<i<<'\t'<<Tf_NOW<<'\t'<<Yd_NOW / 1000;

            outfilePr<<pr<<'('<<i<<'\t'<<momr<<'\t'<<pr_BFR<<')'<<'\t';
            if(i % ny == 0)outfilePr<<endl;
            outfileXr<<xr<<'('<<i<<'\t'<<epir<<')'<<'\t';
            if(i % ny == 0)outfileXr<<endl;
            outfileTr<<Tr<<'('<<i<<'\t'<<Tr_BFR<<')'<<'\t';
            if(i % ny == 0)outfileTr<<endl;
            outfileHr<<hr<<'('<<i<<')'<<'\t';
            if(i % ny == 0)outfileHr<<endl;
            outfileMr<<rour * wr<<'('<<i<<'\t'<<wr<<'\t'<<wr_BFR<<')'<<'\t';
            if(i % ny == 0)outfileMr<<endl;
            outfileIr<<ir<<'('<<i<<'\t'<<ir_BFR<<')'<<'\t';
            if(i % ny == 0)outfileIr<<endl;
            outfileRour<<rour<<'('<<i<<'\t'<<rour_BFR<<')'<<'\t';
            if(i % ny == 0)outfileRour<<endl;
            //if((j - 1) % 30 == 0)outfileHr0<<i<<'\t'<<h_total<<'\t'<<h_sensible<<endl;
        }

        MTf[0] = 9 * MTf[1] / 8 - MTf[2] / 8;
        for(i0 = 0; i0 <= cycle_XYZ; i0++)MTf_BFR[i0] = MTf[i0];

        for(i0 = 1; i0 <= cycle_XYZ; i0++) {
            if(((i0 - 1) / ny) % 4 == 3){
                Taverage = Taverage + MTaout_BFR[i0] / ny / ntz;
                Yaverage = Yaverage + MYaout_BFR[i0] / ny / ntz;
            }
        }




         for (r0 = 1; r0 <= ntz; r0++){
            Tain_SEG = 0;
            Yain_SEG = 0;
            Taout_SEG = 0;
            Yaout_SEG = 0;
            for (i0 = 1; i0 <= ny ; i0++){
                Tain_SEG = MTain_BFR[ny * ntx * (r0 - 1) + i0] / ny + Tain_SEG;
                Yain_SEG = MYain_BFR[ny * ntx * (r0 - 1) + i0] / ny + Yain_SEG;
                Taout_SEG = MTaout_BFR[ny * ntx * r0 + 1 - i0] / ny + Taout_SEG;
                Yaout_SEG = MYaout_BFR[ny * ntx * r0 + 1 - i0] / ny + Yaout_SEG;
            }
            dlT_SEG = (( Tain_SEG - MTr_BFR[ny * ntx * (r0 - 1)]) - (Taout_SEG - MTr_BFR[ny * ntx * r0]))/log((MTr_BFR[ny * ntx * (r0 - 1)] - Tain_SEG)/(MTr_BFR[ny * ntx * r0] - Taout_SEG));
            QS_SEG = ua * roua * 0.32 * 0.3 * (Tain_SEG * (cpa + cpg * Yain_SEG / 1000) - Taout_SEG * (cpa + cpg * Yaout_SEG / 1000)) / ntz;
            QA_SEG = ua * roua * 0.32 * 0.3 * (Yain_SEG - Yaout_SEG) * 2700 / ntz;
            hS_SEG = QS_SEG / dlT_SEG / Aa / nf / ntx;
            hA_SEG = QA_SEG / dlT_SEG / Aa / nf / ntx;
            outfileHS<<hS_SEG<<'\t';
            outfileHA<<hA_SEG<<'\t';
        }

        outfileHS<<endl;
        outfileHA<<endl;

        outfileTa<<j<<'\t'<<Taverage<<endl;
        if( (j - 1) % 10 == 0)outfileTa0<<j<<'\t'<<Taverage<<endl;
        outfileYa<<j<<'\t'<<Yaverage<<endl;
        if( (j - 1) % 10 == 0)outfileYa0<<j<<'\t'<<Yaverage<<endl;
        //if( (j - 1) % 50 == 0)outfileIrout<<j<<'\t'<<ir<<'\t'<<(1000 * SuperHeatedHT(1000 * SaturatedGPT(45), 80) - ir) * 400 * pi * pow(Ri,2)<<endl;
        //outfileOTH<<j<<'\t'<<Q_total<<'\t'<<h_average<<endl;

        if(!flag_cycle){
             if (re <= cycle_Tc && re != 0){
                mr[2 * ((j - 1) / (cycle_Tc + cycle_Th))] = mr[2 * ((j - 1)/  (cycle_Tc + cycle_Th))] + MRour_BFR[cycle_XYZ] * MWr_BFR[cycle_XYZ] / cycle_Tc;
                cout<<2 * ((j - 1)/  (cycle_Tc + cycle_Th))<<endl;
             }
             else {
                mr[2 * ((j - 1)/  (cycle_Tc + cycle_Th)) + 1] = mr[2 * ((j - 1) /  (cycle_Tc + cycle_Th)) + 1] + MRour_BFR[0] * MWr_BFR[0] / cycle_Th;
                cout<<2 * ((j - 1)/  (cycle_Tc + cycle_Th)) + 1<<endl;
             }
        }

        else{
             if (re <= cycle_Th && re != 0){
                mr[2 * ((j - 1)/  (cycle_Tc + cycle_Th))] = mr[2 * ((j - 1)/  (cycle_Tc + cycle_Th))] + MRour_BFR[0] * MWr_BFR[0] / cycle_Th;
                cout<<2 * ((j - 1)/  (cycle_Tc + cycle_Th))<<endl;
             }
             else{
                 mr[2 * ((j - 1)/  (cycle_Tc + cycle_Th)) + 1] = mr[2 * ((j - 1) /  (cycle_Tc + cycle_Th)) + 1] + MRour_BFR[cycle_XYZ] * MWr_BFR[cycle_XYZ] / cycle_Tc;
                 cout<<2 * ((j - 1)/  (cycle_Tc + cycle_Th)) + 1<<endl;
             }
        }
    }
    cout<<mr[0]<<'\t'<<mr[1]<<'\t'<<mr[2]<<'\t'<<mr[3]<<'\t'<<mr[4]<<'\t'<<mr[5]<<endl;
    outfileTain.close();
    outfileTaout.close();
    outfileTa.close();
    outfileTa0.close();
    outfileYain.close();
    outfileYaout.close();
    outfileYa.close();
    outfileYa0.close();
    outfileTf.close();
    outfileWd_avg.close();
    outfileYd.close();
    outfileWd.close();

    outfilePr.close();
    outfileXr.close();
    outfileTr.close();
    outfileHr.close();
    outfileMr.close();
    outfileIr.close();
    outfileRour.close();
    outfileHS.close();
    outfileHA.close();
    outfileOTH.close();

    return 0;
}

double Air_Humidity(double Yain_BFR, double Yaout_BFR, double Yain_NOW, double ky_BFR, double ky_NOW, double Yd_BFR, double Yd_NOW){
    double Yaout_NOW;
    double c1 = roua / dlt / 2, c2 = roua * ua / 2 / dx;
    double c3_BFR = ky_BFR / 2 / La, c3_NOW = ky_NOW / 2 / La;
    //Yaout_NOW = ( - c1 * (Yain_NOW - Yain_BFR - Yaout_BFR) - c2 * (Yaout_BFR - Yain_BFR - Yain_NOW) + c3_BFR * (Yd_BFR - Yain_BFR / 2 - Yaout_BFR / 2) + c3_NOW * (Yd_NOW - Yain_NOW / 2)) / (c1 + c2 + c3_NOW / 2);
    //Yaout_NOW = ( - c1 * (Yain_NOW - Yain_BFR - Yaout_BFR) - 2 * c2 * (Yaout_BFR - Yain_BFR) + 2 * c3_BFR * (Yd_BFR - Yain_BFR / 2 - Yaout_BFR / 2)) / c1;
    Yaout_NOW = ( - c1 * (Yain_NOW - Yain_BFR - Yaout_BFR) + 2 * c2 *  Yain_NOW + 2 * c3_NOW * (Yd_NOW - Yain_NOW / 2)) / (c1 + 2 * c2 + c3_NOW);
    return Yaout_NOW;
}

double Air_Temperature(double Tain_BFR, double Taout_BFR, double Tain_NOW, double Ya_BFR, double Yain_NOW, double Yaout_NOW, double ky_NOW, double Yd_NOW, double Tf_BFR, double Tf_NOW){
    double Taout_NOW;
    double Ya_NOW = Yain_NOW / 2 + Yaout_NOW / 2;
    double c1_BFR = roua * (cpa + Ya_BFR * cpg / 1000) / dlt / 2, c1_NOW = roua * (cpa + Ya_NOW * cpg / 1000) / dlt / 2;
    double c2_IN = roua * ua * (cpa + Yain_NOW * cpg / 1000) / dx / 2, c2_OUT = roua * ua * (cpa + Yaout_NOW * cpg / 1000) / dx / 2;
    double c3 = ha / 2 / La;
    double c4 = ky_NOW * cpg * (Yd_NOW - Ya_NOW) / 1000 / 2 / La;
    double Ts;
    if(Yd_NOW <= Ya_NOW) Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW + 2 * c2_IN * Tain_NOW + 2 * c3 * (Tf_NOW - Tain_NOW / 2) + c4 * Tain_NOW) / (c1_NOW + 2 * c2_OUT + c3 - c4);
    else Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW + 2 * c2_IN * Tain_NOW + 2 * c3 * (Tf_NOW - Tain_NOW / 2) + 2 * c4 * Tf_NOW) / (c1_NOW + 2 * c2_OUT + c3);
    //Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW - c2_BFR * (Taout_BFR - Tain_BFR) + c2_NOW * Tain_NOW + c3 * (Tf_BFR - Tain_BFR / 2 - Taout_BFR / 2 + Tf_NOW - Tain_NOW / 2)) / (c1_NOW + c2_NOW + c3 / 2);
    //Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW - 2 * c2_BFR * (Taout_BFR - Tain_BFR) + 2 * c3 * (Tf_BFR - Tain_BFR / 2 - Taout_BFR / 2)) / c1_NOW;
    //Taout_NOW = (c1_BFR * (Tain_BFR + Taout_BFR) - c1_NOW * Tain_NOW + 2 * c2_IN * Tain_NOW + 2 * c3 * (Tf_NOW - Tain_NOW / 2)) / (c1_NOW + 2 * c2_OUT + c3);
    return Taout_NOW;
}

double DCHE_Temp(double Tf_BFR, double Tf_FRT, double Tf_BCK, double Wd_avg_temp, double Wd_avg_BFR, double Yd_NOW, double qst_NOW, double Ta_NOW, double Ya_NOW, double ky_NOW, double Tr_NOW, double hr_NOW){

    double Tf;

    double c1 = roucu * epscu * ccu + roual * epsal * cal + roud * epsd * cd;
    double c2_BFR = roud * epsd * cpg * Wd_avg_BFR, c2_NOW = roud * epsd * cpg * Wd_avg_temp;
    double c3 = ha * dlt / LaHX, c4 = hr_NOW * dlt / LrHX;
    double c5 = ky_NOW * dlt * (Ya_NOW - Yd_NOW) / 1000 / LaHX;
    double c6 = epscu * lcu * dlt / dy / dy;
    double ca, cf;

    if(c5 >= 0) ca = c5 * cpg, cf = 0;
    else cf = c5 * cpg, ca = 0;

    Tf = ((c1 + c2_BFR - 2 * c6 ) * Tf_BFR + c6 * (Tf_FRT + Tf_BCK) + c5 * qst_NOW + (c3 + ca) * Ta_NOW + c4 * Tr_NOW) / (c1 + c2_NOW + c3 + c4 - cf);

    return Tf;
}

double Desiccant_Mass(bool flag_ch, int re, double Wd_BFR[], double Yd_temp, double Tf_BFR, double Tf_NOW, double Ya_NOW, double ky_NOW, double qst_BFR, double Wd_NOW[]){

    int i0, i1, i2, i3, i4;
    int j, k;
    double c0, c1_BFR, c1_NOW;
    double **A = new double*[nn + 1];
    for(i1 = 0;i1 < nn + 1;i1++)A[i1] = new double[nn + 1]();
    double *B = new double[nn + 1]();

    int times_yd = 1;
    bool flag_yd = 1;
    double Yd;
    double qst = qst_BFR;
    double Ds_BFR, Ds_NOW;
    double Wd_avg;


    Ds_BFR =  D0 * exp(-0.974e-6 * qst_BFR / (Tf_BFR + 273.15)) / 20;
    c0 = dn / dlt_mass;
    c1_BFR = Ds_BFR / dn / 2;

    while (flag_yd){
        Ds_NOW =  D0 * exp(-0.974e-6 * qst / (Tf_NOW + 273.15)) / 20;
        c1_NOW = Ds_NOW / dn / 2;

        A[0][0] = 3 * c1_NOW;
        A[0][1] = - 4 * c1_NOW;
        A[0][2] = c1_NOW;
        B[0] = 0;

        for(i2 = 1;i2 < nn;i2++){
            A[i2][i2 - 1] = - c1_NOW;
            A[i2][i2 + 1] = - c1_NOW;
            A[i2][i2] = c0 + 2 * c1_NOW;
            B[i2] = c1_BFR * Wd_BFR[i2 - 1] + c1_BFR * Wd_BFR[i2 + 1] + (c0 - 2 * c1_BFR) * Wd_BFR[i2];
        }
        A[nn][nn - 2] =  c1_NOW;
        A[nn][nn - 1] = - 4 * c1_NOW;
        A[nn][nn] = 3 * c1_NOW;
        B[nn] = ky_NOW * (Ya_NOW - Yd_temp) / roud / 1000;

        for(i3 = 1;i3 < nn;i3++){
            A[i3][i3] = A[i3][i3] - A[i3 - 1][i3] * A[i3][i3 - 1] / A[i3 - 1][i3 - 1];
            A[i3][i3 + 1] = A[i3][i3 + 1] - A[i3 - 1][i3 + 1] * A[i3][i3 - 1] / A[i3 - 1][i3 - 1];
            B[i3]= B[i3] - B[i3 - 1] * A[i3][i3 - 1] / A[i3 - 1][i3 - 1];
            A[i3][i3 - 1] = 0;
        }

        A[nn][nn - 1] = A[nn][nn - 1] - A[nn - 2][nn - 1] * A[nn][nn - 2] / A[nn - 2][nn - 2];
        B[nn]= B[nn] - B[nn - 2] * A[nn][nn - 2] / A[nn - 2][nn - 2];
        A[nn][nn - 2] = 0;
        A[nn][nn] = A[nn][nn] - A[nn - 1][nn] * A[nn][nn - 1] / A[nn - 1][nn - 1];
        B[nn]= B[nn] - B[nn - 1] * A[nn][nn - 1] / A[nn - 1][nn - 1];
        A[nn][nn - 1] = 0;

        Wd_NOW[nn] = B[nn] / A[nn][nn];
        if(Wd_NOW[nn] >= Bd)Wd_NOW[nn] = Bd;
        for(i4 = nn - 1;i4 >= 1;i4--){
            Wd_NOW[i4] = (B[i4] - A[i4][i4 + 1] * Wd_NOW[i4 + 1]) / A[i4][i4];
        }
        Wd_NOW[0] = (B[0] - A[0][1] * Wd_NOW[1] -  A[0][2] * Wd_NOW[2]) / A[0][0];

        Yd = ConvertYd(flag_ch, re, Tf_NOW, Wd_NOW[nn]);
        flag_yd = (abs(Yd - Yd_temp)<1e-5) ? 0 : 1;
        Yd_temp = Yd;

        Wd_avg = 0;
        for(i0 = 0;i0 < nn + 1;i0++){
            if(i0 == 0 || i0 == nn)Wd_avg = Wd_avg + Wd_NOW[i0] / 2 / nn;
            else Wd_avg = Wd_avg + Wd_NOW[i0] / nn;
        }
        qst = UpdateQst(Tf_NOW, Wd_avg);
        times_yd++;
    }

    delete [] B;
    for(i1 = 0;i1 < nn + 1;i1++) delete [] A[i1];
    delete [] A;
    return Wd_avg;
}

double ConvertYd (bool flag_ch, int re, double Tf, double Wd){

    double Yd_SAT, Yd, Pvs, RH;

    //Pvs = exp(-5800.2206 / (Tf + 273.15) + 1.3914993 - 0.048640239 * (Tf + 273.15) + 0.000041764768 * pow(Tf + 273.15,2) - 0.000000014452093 * pow(Tf + 273.15,3) + 6.5459673 * log(Tf + 273.15));
    //Yd_SAT = 622  / (Patm / Pvs - 1);
    //Yd = Wd / 0.24 * Yd_SAT;

    int p;
    //if((( re <= cycle_Tc && re != 0) && (!flag_cycle))||((re > cycle_Th || re == 0) && (flag_cycle))){


        for(p = 0; p < 26; p++){
            if(Wda[p] <= Wd && Wd <= Wda[p + 1])break;
            //cout<<Wda[p]<<'\t'<<Wd<<endl;
         }
        if(p == 26){RH = 1;}
        else RH = (Wd - Wda[p]) / (Wda[p + 1] - Wda[p]) * (RHa[p + 1] - RHa[p]) + RHa[p];
    //}
    //else{
         //for(p = 0; p < 12; p++){
            //if(Wdd[p] <= Wd && Wd <= Wdd[p + 1])break;
            //cout<<Wda[p]<<'\t'<<Wd<<endl;
         //}
        //if(p == 12){RH = 1;}
        //else RH = (Wd - Wdd[p]) / (Wdd[p + 1] - Wdd[p]) * (RHd[p + 1] - RHd[p]) + RHd[p];
    //}
    Pvs = exp(-5800.2206 / (Tf + 273.15) + 1.3914993 - 0.048640239 * (Tf + 273.15) + 0.000041764768 * pow(Tf + 273.15,2) - 0.000000014452093 * pow(Tf + 273.15,3) + 6.5459673 * log(Tf + 273.15));

    Yd = 622 * RH / (Patm / Pvs - RH);
    //cout<<p<<'\t'<<Yd<<"here!"<<endl;
    return Yd;


    //if(Wd >= 0.73431) RHd = 1;
    //else {
        //if(Wd >= 0.683 && Wd < 0.73431)RHd = 1 / exp(((Wd -0.68427) / -0.00139 + 36)/ (Tf + 273.15) / (8.314 / 18));
        //else RHd = 1 / exp((pow(- log(Wd / Bd) / Cd, 1/Dd) + 36)/ (Tf + 273.15) / (8.314 / 18));
    //}

    //Pvs = exp(-5800.2206 / (Tf + 273.15) + 1.3914993 - 0.048640239 * (Tf + 273.15) + 0.000041764768 * pow(Tf + 273.15,2) - 0.000000014452093 * pow(Tf + 273.15,3) + 6.5459673 * log(Tf + 273.15));
    //Yd = 622 * RHd / (Patm / Pvs - RHd);
    //return Yd;
}

double UpdateQst(double Tf, double Wd){
    double qst;
    qst = 2700000;
    //qst = hfg * (1.0 + 2.0843 * pow(e,-10.28 * Wd));
    return qst;
}

double UpdateKy(double Ta){

    double ky, Da;
    double NUa, PRa, SCa, SHa;

    Da = 2.302e-5 * pow( (Ta + 273.15) / 256,1.81) * 0.98e5 / Patm;

    NUa = ha * Va / Aa / ka;
    PRa = mua * cpa / ka;
    SCa = mua / roua / Da;
    SHa = NUa * pow(SCa, 1.0 / 3) / pow (PRa , 1.0 / 3);
    ky = roua * SHa * Da * Aa / Va;
    //ky = 0.036;
    return ky;
}

double UpdateHa(){

    double d1, d2;
    double Ao, Afr;
    double af, tht, Dh, dc;
    double Umax, REa, PRa;
    double c3, c4, c5, c6, j;
    double ha;

    d1 = dlz - 2 * Ro;
    d2 = 2 * (pow(pow(dlz / 2, 2) + pow(dlx, 2), 0.5) - 2 * Ro);
    if(d1 < d2) Ao = nf * Pf * (1 - (tf + 2 * td) / Pf) * ((ntz - 1) * d1 + d1);
    else Ao = nf * Pf * (1 - (tf + 2 * td) / Pf) * ((ntz - 1) * d2 + d1);
    Afr = nf * Pf * dlz * ntz;

    af = Aa / Va;
    tht = Ao / Afr;
    Dh = 4 * tht / af;
    dc = 2 * Ro + 2 * td + 2 * tf;

    Umax = ua * Afr / Ao;
    REa = roua * Umax * dc / mua;
    PRa = mua * cpa / ka;                                                              /**普朗克常数：定义式**/

    c3 = - 0.361 - 0.042 * ntx / log(REa) + 0.158 * log(ntx * pow(Pf / dc, 0.41));
    c4 = - 1.224 - 0.076 * pow(dlx / Dh, 1.42) / log(REa);
    c5 = - 0.083 + 0.058 * ntx / log(REa);
    c6 = - 5.735 + 1.21 * log(REa / ntx);
    j = 0.086 * pow(REa, c3) * pow(ntx, c4) * pow(Pf / dc, c5) * pow(Pf / Dh, c6) * pow(Pf / dlz, -0.93);

    ha = j / pow(PRa, 2.0 / 3) * roua * Umax * cpa;

    return ha;
}
